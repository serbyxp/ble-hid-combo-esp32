<!doctype html>
<html lang="en">

<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>ESP32 HID Bridge</title>
  <style>
    body {
      font: 14px/1.45 system-ui, Segoe UI, Roboto, Ubuntu, sans-serif;
      margin: 24px;
      color: #0b1320;
    }

    fieldset {
      max-width: 720px;
      border: 1px solid #d1d5db;
      border-radius: 12px;
      padding: 16px;
      margin: 1.5rem 0;
    }

    legend {
      font-weight: 600;
      padding: 0 0.25rem;
    }

    .row {
      margin: .6rem 0;
    }

    .netlist {
      border: 1px solid #d1d5db;
      border-radius: 8px;
      padding: .6rem .75rem;
    }

    .ssid {
      display: flex;
      gap: .5rem;
      align-items: center;
      margin: .25rem 0;
    }

    .rssi {
      font-size: 12px;
      color: #6b7280;
      flex: 0 0 auto;
      white-space: nowrap;
    }

    button,
    input[type=submit],
    select {
      padding: .5rem .9rem;
      border-radius: 8px;
      border: 1px solid #9ca3af;
      background: #eef;
      font: inherit;
    }

    button:disabled,
    input[type=submit]:disabled {
      opacity: 0.6;
    }

    label input:not([type=radio]):not([type=checkbox]),
    label select {
      display: block;
      margin-top: .35rem;
      width: 100%;
      box-sizing: border-box;
      padding: .5rem .65rem;
      border-radius: 8px;
      border: 1px solid #9ca3af;
      font: inherit;
    }

    .ssid input[type=radio] {
      width: auto;
      margin: 0;
      display: inline-flex;
      flex: 0 0 auto;
    }

    .ssid-name {
      flex: 1;
      min-width: 0;
    }

    .muted {
      color: #6b7280;
      font-size: 12px;
    }

    .controls {
      display: flex;
      gap: .5rem;
      flex-wrap: wrap;
      align-items: center;
    }

    .peer-section {
      display: flex;
      flex-direction: column;
      gap: .6rem;
      width: 100%;
      margin-top: 1rem;
    }

    .peer-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: .5rem;
    }

    .peer-actions {
      display: flex;
      gap: .5rem;
      flex-wrap: wrap;
      justify-content: flex-end;
    }

    .peer-list {
      border: 1px solid #d1d5db;
      border-radius: 8px;
      padding: .5rem .75rem;
      background: #f9fafb;
      display: flex;
      flex-direction: column;
      gap: .35rem;
    }

    .peer {
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: .75rem;
      padding: .2rem 0;
      border-bottom: 1px solid #e5e7eb;
    }

    .peer:last-child {
      border-bottom: none;
    }

    .peer-details {
      flex: 1;
      min-width: 0;
    }

    .peer-name {
      font-weight: 600;
    }

    .peer-meta {
      font-size: 12px;
      color: #6b7280;
      display: flex;
      flex-wrap: wrap;
      gap: .35rem;
      align-items: center;
    }

    .peer-status {
      font-size: 12px;
      padding: .1rem .55rem;
      border-radius: 999px;
    }

    .peer-status.connected {
      background: #d1fae5;
      color: #065f46;
    }

    .peer-status.disconnected {
      background: #e5e7eb;
      color: #4b5563;
    }

    .peer-empty {
      text-align: center;
      padding: .4rem 0;
    }

    .ws-log {
      border: 1px dashed #d1d5db;
      border-radius: 8px;
      padding: .6rem .75rem;
      font-family: ui-monospace, SFMono-Regular, SFMono, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      font-size: 12px;
      white-space: pre-wrap;
      background: #f5f7ff;
      min-height: 80px;
    }

    .test-controls {
      display: flex;
      gap: .5rem;
      flex-wrap: wrap;
      align-items: center;
    }
  </style>
</head>

<body>
  <h1>ESP32 BLE HID Bridge</h1>
  <p class="muted">Connect to the ESP32 SoftAP (<code>ESP32-HID-Setup</code>) using password <code>uhid1234</code>.</p>

  <fieldset>
    <legend>Wi‑Fi setup</legend>

    <div class="row muted">Hostname: <span id="hostname">—</span></div>
    <div class="row muted">STA · IP <span id="staIp">—</span> · MAC <span id="staMac">—</span> · SSID <span
        id="connSsid">—</span></div>
    <div class="row muted">AP · IP <span id="apIp">—</span> · MAC <span id="apMac">—</span></div>
    <div class="row muted">AP clients (<span id="apClientCount">0</span>): <span id="apClients">—</span></div>

    <div class="row controls">
      <button id="scanToggle" type="button">Start scan</button>
      <button id="resultsRefresh" type="button">Refresh results</button>
      <span id="scanState" class="muted"></span>
    </div>

    <div class="row">
      <div id="netlist" class="netlist">
        <div class="muted">(scanning…)</div>
      </div>
    </div>

    <form id="cfg" class="row" autocomplete="off">
      <input id="ssid" name="ssid" type="hidden">
      <label class="row">Password (optional)
        <input id="password" name="password" type="password" placeholder="••••••••">
      </label>
      <div class="row controls">
        <input type="submit" value="Connect">
        <span id="msg" class="muted"></span>
      </div>
    </form>
    <div class="muted row">Leave the password blank to join open networks.</div>
    <div class="muted row">Wi‑Fi credentials are stored by ESP‑IDF (NVS). This page stores only the last SSID.</div>
  </fieldset>

  <fieldset>
    <legend>Bluetooth HID &amp; tests</legend>

    <div class="row muted">BLE status: <span id="bleState">—</span></div>
    <div class="row muted">UART bridge: <span id="uartStatus">—</span></div>
    <div class="row muted">WebSocket: <span id="wsStatus">connecting…</span></div>

    <div class="row test-controls">
      <label>Test payload
        <select id="bleTestSelect">
          <option value="mouse">Mouse wiggle (dx=10, dy=0)</option>
          <option value="keyboard">Keyboard tap (Space)</option>
          <option value="consumer">Consumer control (Volume Up)</option>
        </select>
      </label>
      <button id="bleTestSend" type="button">Send test</button>
    </div>
    <div class="row">
      <span id="bleTestMessage" class="muted"></span>
    </div>

    <div class="peer-section">
      <div class="peer-header">
        <span class="muted">Bonded devices (<span id="bondedCount">—</span>)</span>
        <div class="peer-actions">
          <button id="refreshPeers" type="button">Refresh peers</button>
          <button id="forgetAll" type="button">Forget all</button>
        </div>
      </div>
      <div id="blePeerList" class="peer-list">
        <div class="muted peer-empty">(loading peers…)</div>
      </div>
    </div>

    <div class="row">
      <div id="wsLog" class="ws-log muted">(no WebSocket messages yet)</div>
    </div>
  </fieldset>

  <script>
    (function () {
      const netlist = document.getElementById('netlist');
      const form = document.getElementById('cfg');
      const ssidHidden = document.getElementById('ssid');
      const msg = document.getElementById('msg');
      const scanToggle = document.getElementById('scanToggle');
      const resultsRefresh = document.getElementById('resultsRefresh');
      const scanState = document.getElementById('scanState');
      const staIp = document.getElementById('staIp');
      const apIp = document.getElementById('apIp');
      const hostnameEl = document.getElementById('hostname');
      const staMac = document.getElementById('staMac');
      const apMac = document.getElementById('apMac');
      const apClients = document.getElementById('apClients');
      const apClientCount = document.getElementById('apClientCount');
      const connSsid = document.getElementById('connSsid');
      const bleState = document.getElementById('bleState');
      const uartStatus = document.getElementById('uartStatus');
      const wsStatus = document.getElementById('wsStatus');
      const peerList = document.getElementById('blePeerList');
      const peerRefresh = document.getElementById('refreshPeers');
      const bondedCount = document.getElementById('bondedCount');
      const forgetAll = document.getElementById('forgetAll');
      const wsLog = document.getElementById('wsLog');
      const bleTestSelect = document.getElementById('bleTestSelect');
      const bleTestSend = document.getElementById('bleTestSend');
      const bleTestMessage = document.getElementById('bleTestMessage');
      const passwordInput = document.getElementById('password');

      let selected = '';
      let lastSavedSsid = null;
      let configureState = 'idle';
      let lastConfigureVersion = 0;
      let redirectTimer = null;
      let lastPeerCount = null;
      let peersLoading = false;
      let peersReloadPending = false;
      let lastStaIpDisplay = '';
      let ws;
      let statusPollTimer = null;
      let statusPollInFlight = false;
      let statusPollImmediate = false;
      const STATUS_POLL_ACTIVE_MS = 2000;
      const STATUS_POLL_IDLE_MS = 6000;
      const STATUS_POLL_HIDDEN_MS = 15000;
      let scanActive = false;
      let resultsPollTimer = null;
      let resultsPollInFlight = false;
      let resultsPollImmediate = false;
      const RESULTS_POLL_INTERVAL_MS = 5000;

      function escapeHtml(s) { return s.replace(/[&<>\"]/g, c => ({ '&': '&amp;', '<': '&lt;', '>': '&gt;', '\"': '&quot;' }[c])); }

      function syncSelectedRadios() {
        const radios = document.querySelectorAll('input[name="ssid_radio"]');
        radios.forEach(r => {
          r.checked = !!selected && r.value === selected;
        });
      }

      function setSelected(ssid) {
        const next = (typeof ssid === 'string') ? ssid : '';
        if (selected === next) {
          ssidHidden.value = next;
          syncSelectedRadios();
          return;
        }
        selected = next;
        ssidHidden.value = next;
        syncSelectedRadios();
      }

      function appendWsLog(line, isError = false) {
        if (!wsLog) return;
        const time = new Date().toLocaleTimeString();
        const prefix = isError ? '[error]' : '[info]';
        const next = `${time} ${prefix} ${line}`;
        wsLog.classList.remove('muted');
        wsLog.textContent = wsLog.textContent && wsLog.textContent.indexOf('(no WebSocket messages yet)') === -1
          ? wsLog.textContent + '\n' + next
          : next;
      }

      setSelected('');

      function cancelResultsPoll() {
        if (resultsPollTimer) {
          clearTimeout(resultsPollTimer);
          resultsPollTimer = null;
        }
        resultsPollImmediate = false;
      }

      function scheduleResultsPoll(delay) {
        if (resultsPollTimer) {
          clearTimeout(resultsPollTimer);
        }
        resultsPollTimer = setTimeout(resultsPollTick, Math.max(0, delay));
      }

      async function resultsPollTick() {
        if (resultsPollInFlight) return;

        // Check if we should still be polling BEFORE starting work
        if (!scanActive || document.visibilityState === 'hidden') {
          cancelResultsPoll();
          return;
        }

        resultsPollInFlight = true;
        resultsPollImmediate = false;
        try {
          await fetchResults(true);
        } catch (err) {
          /* fetchResults already reports errors */
        } finally {
          resultsPollInFlight = false;
          const visible = document.visibilityState !== 'hidden';
          const pendingImmediate = resultsPollImmediate;
          resultsPollImmediate = false;

          // Double-check scan is still active before scheduling next poll
          if (scanActive && visible) {
            const nextDelay = pendingImmediate ? 0 : RESULTS_POLL_INTERVAL_MS;
            scheduleResultsPoll(nextDelay);
          } else {
            cancelResultsPoll();
          }
        }
      }

      function scheduleStatusPoll(delay) {
        if (statusPollTimer) {
          clearTimeout(statusPollTimer);
        }
        statusPollTimer = setTimeout(statusPollTick, Math.max(0, delay));
      }

      async function statusPollTick() {
        if (statusPollInFlight) return;
        statusPollInFlight = true;
        statusPollImmediate = false;
        try {
          await fetchStatus();
        } catch (err) {
          /* ignore individual poll errors */
        } finally {
          statusPollInFlight = false;
          const visible = document.visibilityState !== 'hidden';
          const pendingImmediate = statusPollImmediate;
          statusPollImmediate = false;
          const baseDelay = visible
            ? (scanActive ? STATUS_POLL_ACTIVE_MS : STATUS_POLL_IDLE_MS)
            : STATUS_POLL_HIDDEN_MS;
          const nextDelay = pendingImmediate ? 0 : baseDelay;
          scheduleStatusPoll(nextDelay);
        }
      }

      function requestImmediateStatusPoll() {
        if (statusPollInFlight) {
          statusPollImmediate = true;
        } else {
          statusPollTick();
        }
      }

      function requestImmediateResultsPoll() {
        if (!scanActive || document.visibilityState === 'hidden') {
          resultsPollImmediate = true;
          return;
        }
        resultsPollImmediate = true;
        if (!resultsPollInFlight) {
          resultsPollTick();
        }
      }

      function updateScanState(active) {
        const next = !!active;
        if (scanState) {
          scanState.textContent = next ? 'scanning' : 'idle';
        }
        if (scanToggle) {
          scanToggle.textContent = next ? 'Stop scan' : 'Start scan';
        }

        const wasActive = scanActive;
        scanActive = next;

        // Start or stop polling based on state change
        if (scanActive && !wasActive) {
          // Just became active - start polling
          requestImmediateResultsPoll();
        } else if (!scanActive && wasActive) {
          // Just became inactive - stop polling
          cancelResultsPoll();
        }
      }

      function render(nets) {
        if (!nets.length) { netlist.innerHTML = '<div class="muted">(no networks found)</div>'; return; }
        const frag = document.createDocumentFragment();
        nets.forEach(n => {
          const label = document.createElement('label');
          label.className = 'ssid';
          label.innerHTML = `<input type="radio" name="ssid_radio" value="${escapeHtml(n.ssid)}">` +
            `<span class="ssid-name">${escapeHtml(n.ssid)}</span>` +
            `<span class="rssi">rssi ${n.rssi}</span>`;
          const input = label.querySelector('input');
          input.checked = (selected !== '' && n.ssid === selected);
          input.addEventListener('change', () => {
            setSelected(input.value);
          });
          frag.appendChild(label);
        });
        netlist.innerHTML = '';
        netlist.appendChild(frag);
      }

      function renderStaIp(ip, url) {
        const value = (typeof ip === 'string') ? ip.trim() : '';
        const href = (typeof url === 'string' && url) ? url : (value ? `http://${value}` : '');
        if (!value) {
          lastStaIpDisplay = '';
          staIp.textContent = '—';
          return;
        }
        if (value === lastStaIpDisplay && staIp.firstChild && staIp.firstChild.textContent === value) {
          return;
        }
        lastStaIpDisplay = value;
        while (staIp.firstChild) {
          staIp.removeChild(staIp.firstChild);
        }
        const node = document.createElement(href ? 'a' : 'span');
        node.textContent = value;
        if (href) {
          try {
            node.href = new URL(href, window.location.href).toString();
          } catch (e) {
            node.href = href;
          }
          node.target = '_blank';
          node.rel = 'noopener noreferrer';
        }
        staIp.appendChild(node);
      }

      function scheduleRedirect(ip, url) {
        if (!ip || redirectTimer) return;

        // Only redirect if we're currently on the AP interface
        const currentHostname = window.location.hostname;
        // Don't redirect if we're already on the target IP
        if (currentHostname === ip) return;

        let next = null;
        if (typeof url === 'string' && url) {
          try {
            next = new URL(url, window.location.href);
          } catch (e) { /* ignore invalid URL */ }
        }
        if (!next) {
          next = new URL(window.location.href);
          next.hostname = ip;
          next.protocol = window.location.protocol;
          next.port = window.location.port;
          next.pathname = '/';
          next.search = '';
          next.hash = '';
        }
        if (msg.textContent.indexOf('Redirecting') === -1) {
          msg.textContent = (msg.textContent ? msg.textContent + ' ' : '') + `Redirecting to ${ip}…`;
        }
        redirectTimer = setTimeout(() => {
          window.location.href = next.toString();
        }, 1500);
      }

      function applyConfigureStatus(cfg) {
        if (!cfg || typeof cfg !== 'object') return;
        const version = Number.isFinite(cfg.version) ? cfg.version : lastConfigureVersion;
        if (version !== lastConfigureVersion) {
          lastConfigureVersion = version;
        }
        const state = (cfg.state || 'idle').toLowerCase();
        configureState = state;
        const message = cfg.message || '';
        if (state === 'pending') {
          msg.textContent = message || 'connecting…';
        } else if (state === 'success') {
          const display = message || 'connected';
          const url = (cfg && typeof cfg.sta_url === 'string' && cfg.sta_url)
            ? cfg.sta_url
            : (cfg.sta_ip ? `http://${cfg.sta_ip}` : '');
          msg.textContent = '';
          msg.appendChild(document.createTextNode(display));
          if (url) {
            msg.appendChild(document.createTextNode(' '));
            const link = document.createElement('a');
            try {
              link.href = new URL(url, window.location.href).toString();
            } catch (e) {
              link.href = url;
            }
            link.textContent = url;
            link.target = '_blank';
            link.rel = 'noopener noreferrer';
            msg.appendChild(link);
          }
          if (cfg.sta_ip) {
            scheduleRedirect(cfg.sta_ip, url);
          }
        } else if (state === 'failed') {
          msg.textContent = message || 'connection failed';
        } else if (message) {
          msg.textContent = message;
        } else {
          msg.textContent = '';
        }
      }

      function renderPeers(peers) {
        if (!peerList) return;
        peerList.innerHTML = '';
        if (peers === null) {
          const div = document.createElement('div');
          div.className = 'muted peer-empty';
          div.textContent = 'failed to load peers';
          peerList.appendChild(div);
          return;
        }
        if (!Array.isArray(peers) || peers.length === 0) {
          const div = document.createElement('div');
          div.className = 'muted peer-empty';
          div.textContent = '(no bonded devices)';
          peerList.appendChild(div);
          return;
        }
        const frag = document.createDocumentFragment();
        peers.forEach(p => {
          const row = document.createElement('div');
          row.className = 'peer';

          const details = document.createElement('div');
          details.className = 'peer-details';
          const nameEl = document.createElement('div');
          nameEl.className = 'peer-name';
          const trimmedName = (p.name || '').trim();
          nameEl.textContent = trimmedName || '(unnamed device)';
          const meta = document.createElement('div');
          meta.className = 'peer-meta';
          const typeLabel = p.addr_type || 'unknown';
          const addrLabel = p.addr || '';
          meta.textContent = `${typeLabel} · ${addrLabel || 'unknown'}`;
          meta.appendChild(document.createTextNode(' '));
          const status = document.createElement('span');
          const isConnected = !!p.connected;
          status.className = 'peer-status ' + (isConnected ? 'connected' : 'disconnected');
          status.textContent = isConnected ? 'connected' : 'not connected';
          meta.appendChild(status);
          details.appendChild(nameEl);
          details.appendChild(meta);
          row.appendChild(details);

          const forgetBtn = document.createElement('button');
          forgetBtn.textContent = 'Forget';
          forgetBtn.type = 'button';
          forgetBtn.addEventListener('click', async () => {
            const label = trimmedName || addrLabel || p.id || 'device';
            if (!confirm(`Forget ${label}?`)) return;
            forgetBtn.disabled = true;
            try {
              const resp = await fetch('/ble/peers/' + encodeURIComponent(p.id), { method: 'DELETE' });
              if (resp.ok) {
                const body = await resp.json().catch(() => null);
                if (body && typeof body.bonded_count === 'number') {
                  bondedCount.textContent = body.bonded_count;
                  lastPeerCount = body.bonded_count;
                }
                fetchPeers(true);
              } else {
                alert('Failed to forget device');
              }
            } catch (err) {
              alert('Failed to forget device');
            } finally {
              forgetBtn.disabled = false;
            }
          });
          row.appendChild(forgetBtn);
          frag.appendChild(row);
        });
        peerList.appendChild(frag);
      }

      async function fetchPeers(force = false) {
        if (peersLoading) {
          if (force) {
            peersReloadPending = true;
          }
          return;
        }
        peersLoading = true;
        try {
          const resp = await fetch('/ble/peers', { cache: 'no-store' });
          if (!resp.ok) throw new Error('peers');
          const data = await resp.json();
          const peers = Array.isArray(data.peers) ? data.peers : [];
          renderPeers(peers);
          const count = Number.isFinite(data.bonded_count) ? data.bonded_count : peers.length;
          bondedCount.textContent = count;
          lastPeerCount = count;
        } catch (err) {
          renderPeers(null);
        } finally {
          peersLoading = false;
          if (peersReloadPending) {
            peersReloadPending = false;
            fetchPeers();
          }
        }
      }

      async function fetchStatus() {
        try {
          const r = await fetch('/status', { cache: 'no-store' });
          if (!r.ok) return;
          const s = await r.json();
          const staInfo = (s.sta && typeof s.sta === 'object') ? s.sta : {};
          const apInfo = (s.ap && typeof s.ap === 'object') ? s.ap : {};
          hostnameEl.textContent = s.hostname || '—';
          const ip = staInfo.ip || s.sta_ip || '';
          const url = staInfo.url || s.sta_url || (ip ? `http://${ip}` : '');
          renderStaIp(ip, url);
          apIp.textContent = apInfo.ip || s.ap_ip || '—';
          connSsid.textContent = staInfo.ssid || s.connected_ssid || '—';
          staMac.textContent = staInfo.mac || s.sta_mac || '—';
          apMac.textContent = apInfo.mac || s.ap_mac || '—';
          const clients = Array.isArray(apInfo.clients) ? apInfo.clients : [];
          const clientCount = Number.isFinite(apInfo.client_count) ? apInfo.client_count : clients.length;
          apClientCount.textContent = clientCount;
          if (clients.length) {
            apClients.textContent = clients.map(c => {
              const mac = c && c.mac ? c.mac : '??';
              const ipLabel = (c && typeof c.ip === 'string' && c.ip) ? c.ip : '';
              const rssiLabel = (c && Number.isFinite(c.rssi)) ? `${c.rssi} dBm` : '';
              return [mac, ipLabel, rssiLabel].filter(Boolean).join(' · ');
            }).join(', ');
          } else {
            apClients.textContent = 'none';
          }
          bleState.textContent = s.ble_connected ? 'connected' : 'idle';
          uartStatus.textContent = s.uart_seen_data ? 'data seen' : 'no data yet';
          const isScanActive = !!s.scan_active;
          updateScanState(isScanActive);
          const saved = (typeof s.last_ssid === 'string') ? s.last_ssid : '';
          if (saved !== lastSavedSsid) {
            lastSavedSsid = saved;
            setSelected(saved);
          }
          if (typeof s.bonded_count === 'number' && isFinite(s.bonded_count)) {
            bondedCount.textContent = s.bonded_count;
            if (lastPeerCount === null || s.bonded_count !== lastPeerCount) {
              fetchPeers(true);
            }
          }
          applyConfigureStatus(s.configure);
        } catch (e) {/* ignore */ }
      }

      async function fetchResults(quiet = false) {
        try {
          const r = await fetch('/scan/results', { cache: 'no-store' });
          if (!r.ok) return;
          const nets = await r.json();
          nets.sort((a, b) => (b.rssi - a.rssi) || a.ssid.localeCompare(b.ssid));
          render(nets);
          if (!quiet && configureState === 'idle') {
            msg.textContent = 'results updated ' + new Date().toLocaleTimeString();
          }
        } catch (e) {
          if (!quiet && configureState === 'idle') {
            msg.textContent = 'fetch results failed';
          }
        }
      }

      form.addEventListener('submit', async (e) => {
        e.preventDefault();
        const ssid = ssidHidden.value.trim();
        const password = passwordInput.value;
        if (!ssid) { msg.textContent = 'pick an SSID'; return; }
        if (redirectTimer) { clearTimeout(redirectTimer); redirectTimer = null; }
        configureState = 'pending';
        msg.textContent = 'connecting…';
        try {
          const r = await fetch('/configure', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ ssid, password })
          });
          if (!r.ok) {
            configureState = 'idle';
            msg.textContent = 'request failed';
            return;
          }
          await r.text();
          msg.textContent = 'connect request sent… awaiting status';
        } catch (e) {
          configureState = 'idle';
          msg.textContent = 'request error';
        }
      });

      resultsRefresh.addEventListener('click', () => {
        fetchResults(false);
      });

      scanToggle.addEventListener('click', async () => {
        if (scanToggle.textContent === 'Start scan') {
          scanToggle.disabled = true;
          try {
            const r = await fetch('/scan/start', { method: 'POST' });
            if (r.ok) {
              updateScanState(true);
              requestImmediateStatusPoll();
            }
          } catch (e) { }
          scanToggle.disabled = false;
        } else {
          scanToggle.disabled = true;
          try {
            const r = await fetch('/scan/stop', { method: 'POST' });
            if (r.ok) {
              updateScanState(false);
              requestImmediateStatusPoll();
            }
          } catch (e) { }
          scanToggle.disabled = false;
        }
      });

      if (peerRefresh) {
        peerRefresh.addEventListener('click', () => fetchPeers(true));
      }

      function wsUrl() { const u = new URL('/ws', location.href); u.protocol = u.protocol.replace('http', 'ws'); return u; }

      function setWsStatus(text) {
        if (wsStatus) {
          wsStatus.textContent = text;
        }
      }

      function connectWS() {
        try {
          ws = new WebSocket(wsUrl());
        } catch (err) {
          setWsStatus('error');
          appendWsLog('failed to create WebSocket: ' + err, true);
          return;
        }
        setWsStatus('connecting…');
        ws.onopen = () => {
          setWsStatus('connected');
          appendWsLog('websocket connected');
        };
        ws.onmessage = ev => {
          const data = ev.data;
          appendWsLog('rx ' + data);
        };
        ws.onerror = () => {
          appendWsLog('websocket error', true);
        };
        ws.onclose = () => {
          setWsStatus('disconnected');
          appendWsLog('websocket closed', true);
          setTimeout(connectWS, 1000);
        };
      }

      connectWS();

      async function sendBleTest() {
        if (!ws || ws.readyState !== WebSocket.OPEN) {
          bleTestMessage.textContent = 'WebSocket not connected. Wait for connection...';
          bleTestMessage.style.color = '#dc2626';
          return;
        }
        const choice = bleTestSelect.value;
        bleTestMessage.textContent = 'Sending test…';
        bleTestMessage.style.color = '';

        try {
          if (choice === 'mouse') {
            const payload = { type: 'mouse', dx: 10, dy: 0, wheel: 0, b1: 0, b2: 0, b3: 0 };
            ws.send(JSON.stringify(payload));
            appendWsLog('tx ' + JSON.stringify(payload));
            bleTestMessage.textContent = 'Mouse wiggle sent. Check if cursor moved.';
            bleTestMessage.style.color = '#059669';
          } else if (choice === 'keyboard') {
            // Send key down
            const down = { type: 'key', mods: 0, keys: [0x2C] };
            ws.send(JSON.stringify(down));
            appendWsLog('tx ' + JSON.stringify(down));
            bleTestMessage.textContent = 'Sending space key...';

            // Wait then send key up
            setTimeout(() => {
              if (ws && ws.readyState === WebSocket.OPEN) {
                const up = { type: 'key', mods: 0, keys: [] };
                ws.send(JSON.stringify(up));
                appendWsLog('tx ' + JSON.stringify(up));
                bleTestMessage.textContent = 'Space key sent. Check if it typed a space.';
                bleTestMessage.style.color = '#059669';
              }
            }, 100);
          } else if (choice === 'consumer') {
            const payload = { type: 'consumer', usage: 0x00E9 };
            ws.send(JSON.stringify(payload));
            appendWsLog('tx ' + JSON.stringify(payload));
            bleTestMessage.textContent = 'Consumer control sent (Volume Up usage).';
            bleTestMessage.style.color = '#059669';
          } else {
            bleTestMessage.textContent = 'Unknown test selected.';
            bleTestMessage.style.color = '#dc2626';
          }
        } catch (err) {
          bleTestMessage.textContent = 'Failed to send: ' + err.message;
          bleTestMessage.style.color = '#dc2626';
          appendWsLog('send error: ' + err, true);
        }
      }

      bleTestSend.addEventListener('click', sendBleTest);

      // initial data + polling
      fetchResults();
      fetchPeers();
      statusPollTick();

      document.addEventListener('visibilitychange', () => {
        if (document.visibilityState === 'hidden') {
          cancelResultsPoll();
        } else {
          requestImmediateStatusPoll();
          if (scanActive) {
            requestImmediateResultsPoll();
          }
        }
      });

      // BLE bonded controls
      forgetAll.addEventListener('click', async () => {
        if (!confirm('Forget all bonded BLE devices?')) return;
        forgetAll.disabled = true;
        try {
          const r = await fetch('/ble/peers/forget', { method: 'POST' });
          if (r.ok) {
            const j = await r.json();
            bondedCount.textContent = j.after;
            lastPeerCount = j.after;
            alert('Forgot ' + (j.before - j.after) + ' peers');
            fetchPeers(true);
          }
        } catch (e) { }
        forgetAll.disabled = false;
      });
    })();
  </script>
</body>

</html>